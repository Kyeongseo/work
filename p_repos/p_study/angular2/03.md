03. 타입스크립트
===
본 문서는 __'쉽고 빠르게 배우는 Angular2 프로그래밍'(위키북스)__를 참고해 작성합니다.

3.1 ECMA 스크립트 소개
---
타입스크립트가 따르는 표준은 ECMA(European Computer Manufacturers Association) 표준.

__3.1.1 ECMA 스크립트의 역사__

자바스크립트는 ECMA 스크립트 표준을 따르고 있다.
- ES5 표준을 기반으로해 Node.js 플랫폼 등장. 자바스크립트가 브라우저만의 언어가 아닌 서버 프로그래밍이 가능한 언어로 확장.

__3.1.2 ECMA 스크립트와 타입스크립트__
- ES5
	- 현재 브라우저가 지원할 수 있는 자바스크립트 표준.
	- JSON(Java Script Object Notation)
	- Strict Mode(문법 검사를 엄격하게)
- ES6
	- 클래스 문법
	- 모듈 기능
- ES7
	- 장식자(decorator)
	- 비동기 처리 Asnyc/Await

타입스크립트가 지원하는 특징은 최신 ES7 포함. (타입스크립트 = ~ES7 + 타입) 하지만 브라우저가 ES5에 머물고 있어 한계가 있다.

__3.1.3 타입스크립트 소개__

타입스크립트는 자바스크립트를 확장한 언어로 자바스크립트 언어의 특성을 침범하지 않고 최신 ECMA표준을 지원한다. (타입스크립트는 자바스크립트의 상위 집합 언어라고도 불린다.)

- 자바스크립트의 미래
	- 타입스크립트는 ECMA 표준을 반영하며 ES5 브라우저에 대응할 수 있는 컴파일러를 지원.
	- 타입스크립트는 자바스크립트와 다르지만 ECMA 스크립트를 따르기 때문에 타입스크립트에서 자바스크립트를 이용할 수 있다.
- 타입 기반 언어
	- __타입스크립트 = 자바스크립트(ECMA 표준) + 타입__
	- 타입스크립트는 명시적 타입을 기반으로 한 언어이다.
	- 타입 기능은 컴파일 단계에서 타입 오류를 잡아낼 수 있게 해준다. 
	- 타입 특징은 자바스크립트의 타입 검사 남발을 방지한다.
		- 자바스크립트가 가진 암묵적인 형변환, 호이스팅 등 복잡성의 문제를 해결해준다.
- Angular의 주력언어, 변환 가능한 언어
	- Angular의 주력 언어는 타입스크립트.
	- 타입스크립트가 ECMA 표준을 다른 스크립트로 변환가능한 언어이다.
	- 해당 언어가 ECMA 표준을 따른다면 타입스크립트는 컴파일 도구를 통해 새로운 언어로 마이그레이션 하도록 지원.

정리해보면 타입스크립트는 ECMA스크립트의 최신 표준을 포함하는 언어이고, 타입 기반 언어이며, 변환 도구를 이용해 다른 언어로 변환이 가능하다.

3.2 타입과 문자열
---

__3.2.1 let을 이용한 변수 선언__

let 선언자
- let 선언자는 ES6표준에서 처음으로 추가된 특징.
- 변수를 선언할 때 변수가 현재 블록 내에서만 유효 범위를 가질 수 있도록 블록 스코프로 처리하기위해 let 선언자 이용.
- 호이스팅 문제를 해결해준다. (선언된 블록 내에서만 유효하다.)
	- 호이스팅, 지역 스코프에 선언된 변수가 전역 스코프에 선언된 변수에 영향을 미치는 현상
- ```let 변수명;```
- ```let 변수명 : 타입;```	// 타입스크립트 (변수에 타입을 추가해 변수를 선언한다.)
- ex) ```let emotion:string = "happy";```

__3.2.2 배열 타입__

배열은 여러 값을 하나의 변수에 담아 관리할 수 있는 타입이다.
- 타입스크립트에서 배열은 두가지 형태로 정의된다.
- 대괄호 앞에 타입을 명시해 선언하는 방식
	- ex) ```let fruits: string[] = ["banana","apple","mango"];	// 문자열 배열 타입
	- ex) ```let fruits: string[] = [];	fruits.push("lemon");	// 선언과 할당 분리. push() 메서드 사용.
- 제너릭 타입(generic types) 형식 지정 방식
	- Array<타입>
	- ex) ```let num:Array<number> = [1,2,3];```
	- ex) ```let num:Array<number> = new Array<number>();	num.push(1)```
- 다차원 배열 선언
	- 대괄호를 한 번 더 붙이는 형식
	- ex) ```var 변수명: 타입[][]```

__3.2.3 유니언 타입__

유니언 타입은 2개 이상으로 입력된 타입에 대해 하나의 타입으로 정의한다.
- 유니언 타입(union types)은 타입스크립트 1.4에 추가된 특징
- 유니언 타입은 둘 중 하나의 타입만 유효하면 할당이 이루어진다.
	- ex) ```var union: string | number = 1;```		출력(typeof)하면 number 출력
	- ex) ```var union: string | number = "1";```	출력(typeof)하면 string 출력
- 허용 타입을 구체적으로 명시해 허용 타입을 제한할 수 있다는 장점이 있다.
- 허용하지 않은 타입이 입력될 때 컴파일 단계에서 에러발생.
- 유니언 타입은 변수 선언뿐 아니라 메서드의 매개변수로 값을 받을때 타입을 제약하는 용도로도 사용.
	- ex) ```function typeCheck(p: string | number): string | number {...}```

__3.2.4 문자열 표현__

타입스크립트에서 문자열을 표현할 때는 string 타입을 이용해 '', ""안에 문자열을 입력한다.
- 탬플릿 문자열
	- 더 간단하게 문자열을 입력하려면 탬플릿 문자열을 이용한다.
	- 탬플릿 문자열은 백틱(backtick) 문자인 `를 이용한다.
	- 백틱 문자를 이용하면 여러줄에 걸쳐 문자열을 입력할 수 있다. (multi line 가능)
	- 문자열에 외부 변수를 입력할 필요가 있으면 표현식에 출력하고자 하는 변수를 입력한다. ` ${표현식} ` // 외부에 선언된 변수값 출력 및 연산 결과 출력

__3.2.5 디스트럭처링 지원__

디스트럭처링(destructuring)은 배열이나 객체에서 데이터를 선택적으로 추출할 수 있는 자바스크립트의 표현식이다.
- ES6 특징
- 간소화된 형태로 배열을 할당하는 기능
	- ex) ```var param = ['aaa',1];		let [name, count] = param;```
	- param 배열 요소의 위치에 대응하는 값을 name, count 변수에 각각 할당.

3.3 메서드
---

__3.3.1 배열 메서드__
- filter()
	- 배열에서 특정 조건에 부합하는 요소만 거르는 메서드
	- arr.filter(콜백 함수)
```
function positiveNumber(value){
	return value > 0;
}
var result = [-1,1,2,3].filter(positiveNumber); 		// 1,2,3 출력됨 
```
- forEach()
	- 배열을 순회하는 역할
	- arr.forEach(콜백 함수)
```
function printArray(element, index, array){
	console.log(index + " : " + element);
}
[1,2,3].forEach(printArray);
```
- filter(), forEach() 메서드에서 사용한 함수는 익명 함수 형태로 전달 가능하다.
- function(요소 값, 요소 인덱스, 순회할 배열){...}
```
[1,2,3].forEach(function(element, index, array){		// 익명 함수
	console.log(index + " : " + element);
});
```

__3.3.2 화살표 함수__

화살표 함수(arrow functions)는 ES6 표준에 포함된 익명 함수를 좀 더 간략하게 표현할 수 있는 방법이다.
- 익명 함수는 함수의 이름을 생략한 함수. 
	- function(){}
- 익명 함수를 화살표 함수로 바꾼다면 function 키워드 생략한 채로 다음과 같은 형태이다.
	- ()=>{}
	- `=>` 기호를 사용한다.(뚱뚱한 화살표)
```
1.
var pow = function(x){ return x * x; }
console.log(pow(3));
2. // function 키워드 생략
var pow = (x)=>{ return x * x; }
console.log(pow(3));
3. //명령식이 한줄이므로 축약
var pow = x => x * x;
console.log(pow(3));
4. //즉시 실행 가능한 함수의 형태
((x) => { console.log( x * x ); })(3);
```

__3.3.3 게터 함수와 세터 함수__

게터, 세터 함수는 ES6에 포함된 기능으로 프로퍼티 설정과 출력 시 특정 처리를 가능하게 한다.
- {set 속성이름(매개변수 선언){...}} 	// 세터 함수는 set 키워드 사용, 할당받을 값에 대한 매개변수 선언.
- {get 속성이름(){...}} 				// 게터 함수는 get 키워드 사용, 반환값을 갖는다.
```
var obj = {					// obj 리터럴 객체
	msg:'',
	get hello(){			// 게터 함수. 
		return this.msg;	// 타입을 선언하지 않은 이유는 리터럴 객체에 선언하는 게터함수에는 반환형을 허용하지 않기 때문이다.
	},						// 게터 함수에 반환형을 선언하려면 클래스 기반으로 변경해야한다.	
	set hello(value){		// 세터 함수
		this.msg = value;
	}
};

obj.hello = "hello";		// hello 출력
```
```
class Hello{
	private hello: string;

	get hello(): string{
		return this.hello;
	}

	set hello(name: string){
		this.hello = name;
	}
}

var m = new Hello();
m.hello = "hello";			// hello 출력
```

3.4 객체지향 프로그래밍
---


__3.4.1 객체지향 프로그래밍 소개__

자바스크립트는 객체지향 프로그래밍(Object-Oriented Programming)을 위한 언어는 아니고 
객체지향 프로그래밍을 대안적인 방법으로 지원했다. 자바스크립트는 객체를 사용하지만 객체지향 언어는 아니다.
- 객체지향 언어라면 클래스와 인터페이서같은 키워드가 지원돼 객체간의 관계를 쉽게 정의하고 구현해야할 수 있어야 한다.
- 현재 ES5는 객체지향에 필요한 필수 요소를 지원하지 않는다. 
- ES6 표준에 클래스가 추가됨. (객체지향에서 가장 중요한 특징인 클래스)
- 클래스는 ES6 표준에 포함된 특징이기 때문에 타입스크립트에서 이용 가능하다.

타입스크립트는 전통적인 객체지행 프로그래밍에서 사용하던 클래스, 인터페이스, 상속 기능을 제공하고 있어 
객체지향 프로그래밍을 가능하게한다.

__3.4.2 클래스 선언과 사용__

클래스는 객체를 정의하기 위한 구조이다.
- 구성
	- 함수
	- 생성자
	- 멤버 변수
```
- 기본적인 선언 형식

class MyClass{
	constructor(){	// 생성자로 클래스가 객체로 생성될 때 기본적으로 호출하는 메서드
	}
}
```
- __클래스는 그 자체로는 사용할 수 없으며 객체로 만들어진 후 사용할 수 있다.__
```
var myClass = new MyClass();
var myClass:MyClass = new MyClass();	// 명시적인 타입 추가

var myClass:MyClass;
myClass = new MyClass();
```
- 전역변수로 선언후 constructor 매개변수로 전달이 아닌 곧바로 생성자 매개변수를 전역화 하고 싶으면
매개변수에 선언한 변수 앞에 public 접근자를 설정한다.
	- public 접근자를 이용하면 생성자의 매개변수가 아닌 클래스의 전역변수로 변수의 유효 범위가 확장된다.
	- ```constructor(public carName:string){}```
	- 이 방법은 생성자로 전달받은 매개변수를 전역 변수로 만들때 클래스 전역에 변수를 선언하는것보다 좋다.

__3.4.3 클래스 상속__

타입스크립트에서는 extends 키워드를 통해 클래스 상속을 지원한다.
- 상속(inheritance)
	- 부모 클래스에 정의된 메서드나 변수를 자식 클래스에서 사용할 수 있게 해주는 기능.
	- 자식 클래스가 부모 클래스 생성자를 호출한다면 다음과 같이 부모 클래스의 생성자로 매개 변수를 전달해야 한다.
		- super(인자1, 인자2 ...)
	- protected 접근자
		- 부모 클래스를 상속받는 자식 클래스에서는 접근할 수 있지만 클래스 외부에서 객체를 통한 접근은 허용하지 않는다.
```
class 부모{
	constructor(){}
	...
}

class 자식 extends 부모{
	constructor(){
		super();	// super() 메서드를 이용해 상위 클래스의 생성자를 호출. 생략할 수 없다.
	}
}
```

__3.4.4 인터페이스__

타입스크립트는 인터페이스(interface)를 지원합니다.
- 장점
	- 인터페이스에 선언된 변수나 메서드의 사용을 구현 클래스에 강제함으로서 클래스 형태에 일관성을 유지할 수 있다.
```
interface 인터페이스명{
	// 메서드나 변수 정의
}
```
- 인터페이스는 상속이 가능하다.
```
interface 부모 인터페이스명{
	// 메서드나 변수 정의
}
interface 자식 인터페이스명 extends 부모 인터페이스명{
	// 메서드나 변수 정의
}
```
- 인터페이스를 클래스에서 구현하도록 강제하려면 implements 키워드 이용하면 된다.
	- 다중 인터페이스 구현 가능
```
class 클래스명 implements 구현해야 할 인터페이스명{
	// 인터페이스에 정의된 메서드나 변수를 추가한 후 구현
	// 클래스 고유의 메서드나 변수를 추가한 후 구현
}
```

__3.4.5 추상 클래스__

추상 클래스(abstract class)는 구현과 강제를 동시에 수행하는 클래스이다.
- abstract 키워드를 이용해 선언
- 추상 클래스 내부
	- 추상 메서드
		- abstract 키워드를 붙여 형식만 정의
		- 선언만 되어있어 추상 메서드의 구현은 추상 클래스를 상속받은 클래스에서 이뤄짐.
	- 구현 메서드
		- abstract 생략한 채로 정의
		- 주로 추상 메서드를 이용하도록 로직을 작성
```
abstract class SmallAnimals{
	abstract 추상 메서드(): string;
	구현 메서드(): string{
		// 추상 메서드를 이용해 구현 메서드의 로직을 추가
	}
}

class Mouse extends SmallAnimals{
	// 추상 클래스에 정의된 추상 메서드를 구현
	// 클래스 고유의 메서드나 변수를 추가
}
```